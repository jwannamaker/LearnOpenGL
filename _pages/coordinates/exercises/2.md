---
layout: detail
title: Coordinates - Exercise 2
permalink: /coordinates/exercises/2.html
order: 38
---

**2. Play with the view matrix by translating in several directions and see how the scene changes. Think of the view matrix as a camera object.**

Initially, I decided to use the arrow keys to translate and rotate the view matrix, hoping to simulate a similar experience to an FPS POV. To do this, I created a simple Camera struct like so:

```c++
struct Camera {
    glm::mat4 view;
    glm::vec3 position;

    Camera(glm::mat4 view, glm::vec3 position)
    {
        this->view = translate(view, position);
        this->position = position;
    }
};
```

My first idea was to keep track of the position associated with the view matrix, so I could more easily determine an axis of rotation to apply on the camera and create the effect of rotating the camera in place like in an FPS style game.

I figured the ```processInput(GLFW* window)``` function was a great place to move my camera movement logic, so I modified the funciton header to accomodate camera transformations: ```processInput(GLFW* window, Camera& camera)```; Below is my thought process for an implementation.

```c++
struct Camera {
	glm::mat4 view;
	glm::vec3 position;

	Camera() 
	{ 
		view = glm::mat4(1.0f);
		position = glm::vec3(0.0f);
	}
	
	void turn(glm::vec2 amount)
	{
		view = rotate(view, amount.x * rotateSpeed(), up()); 
		view = rotate(view, amount.y * rotateSpeed(), right());
	}

	glm::vec3 front(void)
	{
		return glm::vec3(view * glm::vec4(0.0f, 0.0f, 1.0f, 1.0f));
	}

	glm::vec3 right(void)
	{
		return glm::vec3(view * glm::vec4(1.0f, 0.0f, 0.0f, 1.0f));
	}

	glm::vec3 up(void)
	{
		return cross(front(), right());
	}

	float rotateSpeed(void) { return glm::radians(0.05f); }
};
```

```c++
void processInput(GLFWwindow* window, Camera& camera)
{
    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
    {
        glfwSetWindowShouldClose(window, true);
    }

    if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS)
    {
        camera.turn(glm::vec2(+1.0f, 0.0f));
    }
    if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS)
    {
        camera.turn(glm::vec2(-1.0f, 0.0f));
    }

    if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)
    {
        camera.turn(glm::vec2(0.0f, -1.0f));
    }
    if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)
    {
        camera.turn(glm::vec2(0.0f, +1.0f));
    }
}
```