---
layout: detail
title: Coordinates - Exercise 3
permalink: /coordinates/exercises/3.html
order: 40
---

**3. Try to make every 3rd container (including the 1st) rotate over time, while leaving the other containers static using just the model matrix.**

<iframe
    src="https://www.youtube.com/embed/_J3sd-a8BW0?autoplay=1&mute=1&controls=1&modestbranding=1&rel=0&playsinline=1" 
    frameborder="0" 
    allow="autoplay; encrypted-media" 
    allowfullscreen>
</iframe>

For this exercise, I oscillate the position of each cube between a sphere-like formation and a cube-like formation while rotating every other cube. I changed the axis of rotation by parameterizing a unit circle on the xz-plane.

<br>

<iframe
    src="https://www.youtube.com/embed/-kyqUMA7ubw?autoplay=1&mute=1&controls=1&modestbranding=1&rel=0&playsinline=1" 
    frameborder="0" 
    allow="autoplay; encrypted-media" 
    allowfullscreen>
</iframe>

In the above video, I added the x (green), y (red), and z (blue) axes to further clarify the movement pattern of the changing rotation axis.

<figure>
    <iframe
        src="https://www.desmos.com/3d/sk0zlncnr5?embed"
        frameborder="0"
        allowfullscreen>
    </iframe>
    <figcaption>Observe the model transformations by pressing play next to ```t```.</figcaption>
</figure>

Here's a Desmos interactive graph replicating the transformations I performed on the model matrix of every other cube:

<figure>
    <iframe 
        src="https://www.desmos.com/calculator/6sh532p9jp?embed"
        frameborder=0
        allowfullscreen>
    </iframe>
    <figcaption>Function for the model position translation amount.</figcaption>
</figure>

In the main render loop, I add two loops to iterate through the 27 positions I utilized earlier in this section when rendering a 3x3x3 grid of cubes. Once for an outer set of cubes, and again for an inner set of cubes. Each frame, I recreate the model matrix for both sets of inner and outer cubes by updating a time variable, ```t```, then updating the axis of rotation and the translation amount.

```c++
float t = 0.0f;
glm::vec3 rotationAxis = glm::vec3(1.0f);
float rotationAmount = glm::radians(90.0f);

// main render loop
glBindVertexArray(cubesVAO);
while(/* window is open */)
{
    [ ... ] 
        
    t = glfwGetTime(); 
    rotationAxis = glm::vec3(sin(t), 0, cos(t));

    // outer cubes
    for (unsigned int i = 0; i < positions.size(); i++)
    {
        spherePosition = sphereRadius * glm::normalize(positions[i]);
        if (i % 2)
        {
            // optionally set unique color here for greater visual separation of every other cube
            translationAmount = glm::pi<float>() * sin(glm::half_pi<float>() * sin(t)) / 9.0f + 1.0f;
            translation = mix(positions[i], 1.5f * spherePosition, translationAmount);
        }
        else
        {
            // if unique color was set, set the default color here
            translationAmount = glm::pi<float>() * sin(glm::half_pi<float>() * sin(t + glm::pi<float>())) / 9.0f + 1.0f;
            translation = mix(positions[i], spherePosition, translationAmount);
        }
        
        // if color was set per cube, set uniform here
        
        model = glm::mat4(1.0f);
        model = rotate(model, rotationAmount, rotationAxis);
        model = translate(model, tranlation);
        glUniformMatrix4fv(glGetUniformLocation(myShader.ID, "model"), 1, GL_FALSE, glm::value_ptr(model));

        glDrawArrays(GL_TRIANGLES, 0, 36);
    }

    // inner cubes
    for (unsigned int i = 0; i < positions.size(); i++)
    {
        // exact same process as outer cubes, except the radius is multiplied to be smaller
    }

    [ ... ] 
}
```